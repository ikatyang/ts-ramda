export as namespace R;
export * from "./src/$curried-functions";
export * from "./src/$placeholder";
export * from "./src/$types";
import * as __ from "./src/__";
import * as add from "./src/add";
import * as addIndex from "./src/addIndex";
import * as adjust from "./src/adjust";
import * as all from "./src/all";
import * as allPass from "./src/allPass";
import * as always from "./src/always";
import * as and from "./src/and";
import * as any from "./src/any";
import * as anyPass from "./src/anyPass";
import * as ap from "./src/ap";
import * as aperture from "./src/aperture";
import * as append from "./src/append";
import * as apply from "./src/apply";
import * as applySpec from "./src/applySpec";
import * as ascend from "./src/ascend";
import * as assoc from "./src/assoc";
import * as assocPath from "./src/assocPath";
import * as binary from "./src/binary";
import * as bind from "./src/bind";
import * as both from "./src/both";
import * as call from "./src/call";
import * as chain from "./src/chain";
import * as clamp from "./src/clamp";
import * as clone from "./src/clone";
import * as comparator from "./src/comparator";
import * as complement from "./src/complement";
import * as compose from "./src/compose";
import * as composeK from "./src/composeK";
import * as composeP from "./src/composeP";
import * as concat from "./src/concat";
import * as cond from "./src/cond";
import * as construct from "./src/construct";
import * as constructN from "./src/constructN";
import * as contains from "./src/contains";
import * as converge from "./src/converge";
import * as countBy from "./src/countBy";
import * as curry from "./src/curry";
import * as curryN from "./src/curryN";
import * as dec from "./src/dec";
import * as defaultTo from "./src/defaultTo";
import * as descend from "./src/descend";
import * as difference from "./src/difference";
import * as differenceWith from "./src/differenceWith";
import * as dissoc from "./src/dissoc";
import * as dissocPath from "./src/dissocPath";
import * as divide from "./src/divide";
import * as drop from "./src/drop";
import * as dropLast from "./src/dropLast";
import * as dropLastWhile from "./src/dropLastWhile";
import * as dropRepeats from "./src/dropRepeats";
import * as dropRepeatsWith from "./src/dropRepeatsWith";
import * as dropWhile from "./src/dropWhile";
import * as either from "./src/either";
import * as empty from "./src/empty";
import * as endsWith from "./src/endsWith";
import * as eqBy from "./src/eqBy";
import * as eqProps from "./src/eqProps";
import * as equals from "./src/equals";
import * as evolve from "./src/evolve";
import * as F from "./src/F";
import * as filter from "./src/filter";
import * as find from "./src/find";
import * as findIndex from "./src/findIndex";
import * as findLast from "./src/findLast";
import * as findLastIndex from "./src/findLastIndex";
import * as flatten from "./src/flatten";
import * as flip from "./src/flip";
import * as forEach from "./src/forEach";
import * as forEachObjIndexed from "./src/forEachObjIndexed";
import * as fromPairs from "./src/fromPairs";
import * as groupBy from "./src/groupBy";
import * as groupWith from "./src/groupWith";
import * as gt from "./src/gt";
import * as gte from "./src/gte";
import * as has from "./src/has";
import * as hasIn from "./src/hasIn";
import * as head from "./src/head";
import * as identical from "./src/identical";
import * as identity from "./src/identity";
import * as ifElse from "./src/ifElse";
import * as inc from "./src/inc";
import * as indexBy from "./src/indexBy";
import * as indexOf from "./src/indexOf";
import * as init from "./src/init";
import * as innerJoin from "./src/innerJoin";
import * as insert from "./src/insert";
import * as insertAll from "./src/insertAll";
import * as intersection from "./src/intersection";
import * as intersectionWith from "./src/intersectionWith";
import * as intersperse from "./src/intersperse";
import * as into from "./src/into";
import * as invert from "./src/invert";
import * as invertObj from "./src/invertObj";
import * as invoker from "./src/invoker";
import * as is from "./src/is";
import * as isEmpty from "./src/isEmpty";
import * as isNil from "./src/isNil";
import * as join from "./src/join";
import * as juxt from "./src/juxt";
import * as keys from "./src/keys";
import * as keysIn from "./src/keysIn";
import * as last from "./src/last";
import * as lastIndexOf from "./src/lastIndexOf";
import * as length from "./src/length";
import * as lens from "./src/lens";
import * as lensIndex from "./src/lensIndex";
import * as lensPath from "./src/lensPath";
import * as lensProp from "./src/lensProp";
import * as lift from "./src/lift";
import * as liftN from "./src/liftN";
import * as lt from "./src/lt";
import * as lte from "./src/lte";
import * as map from "./src/map";
import * as mapAccum from "./src/mapAccum";
import * as mapAccumRight from "./src/mapAccumRight";
import * as mapObjIndexed from "./src/mapObjIndexed";
import * as match from "./src/match";
import * as mathMod from "./src/mathMod";
import * as max from "./src/max";
import * as maxBy from "./src/maxBy";
import * as mean from "./src/mean";
import * as median from "./src/median";
import * as memoize from "./src/memoize";
import * as memoizeWith from "./src/memoizeWith";
import * as merge from "./src/merge";
import * as mergeAll from "./src/mergeAll";
import * as mergeDeepLeft from "./src/mergeDeepLeft";
import * as mergeDeepRight from "./src/mergeDeepRight";
import * as mergeDeepWith from "./src/mergeDeepWith";
import * as mergeDeepWithKey from "./src/mergeDeepWithKey";
import * as mergeWith from "./src/mergeWith";
import * as mergeWithKey from "./src/mergeWithKey";
import * as min from "./src/min";
import * as minBy from "./src/minBy";
import * as modulo from "./src/modulo";
import * as multiply from "./src/multiply";
import * as nAry from "./src/nAry";
import * as negate from "./src/negate";
import * as none from "./src/none";
import * as not from "./src/not";
import * as nth from "./src/nth";
import * as nthArg from "./src/nthArg";
import * as o from "./src/o";
import * as objOf from "./src/objOf";
import * as of from "./src/of";
import * as omit from "./src/omit";
import * as once from "./src/once";
import * as or from "./src/or";
import * as pair from "./src/pair";
import * as partial from "./src/partial";
import * as partialRight from "./src/partialRight";
import * as partition from "./src/partition";
import * as pathEq from "./src/pathEq";
import * as pathOr from "./src/pathOr";
import * as pathSatisfies from "./src/pathSatisfies";
import * as pick from "./src/pick";
import * as pickAll from "./src/pickAll";
import * as pickBy from "./src/pickBy";
import * as pipe from "./src/pipe";
import * as pipeK from "./src/pipeK";
import * as pipeP from "./src/pipeP";
import * as pluck from "./src/pluck";
import * as prepend from "./src/prepend";
import * as product from "./src/product";
import * as project from "./src/project";
import * as prop from "./src/prop";
import * as propEq from "./src/propEq";
import * as propIs from "./src/propIs";
import * as propOr from "./src/propOr";
import * as props from "./src/props";
import * as propSatisfies from "./src/propSatisfies";
import * as range from "./src/range";
import * as reject from "./src/reject";
import * as remove from "./src/remove";
import * as repeat from "./src/repeat";
import * as replace from "./src/replace";
import * as reverse from "./src/reverse";
import * as slice from "./src/slice";
import * as sort from "./src/sort";
import * as sortBy from "./src/sortBy";
import * as sortWith from "./src/sortWith";
import * as split from "./src/split";
import * as splitAt from "./src/splitAt";
import * as splitEvery from "./src/splitEvery";
import * as splitWhen from "./src/splitWhen";
import * as startsWith from "./src/startsWith";
import * as subtract from "./src/subtract";
import * as sum from "./src/sum";
import * as symmetricDifference from "./src/symmetricDifference";
import * as symmetricDifferenceWith from "./src/symmetricDifferenceWith";
import * as T from "./src/T";
import * as tail from "./src/tail";
import * as take from "./src/take";
import * as takeLast from "./src/takeLast";
import * as takeLastWhile from "./src/takeLastWhile";
import * as takeWhile from "./src/takeWhile";
import * as tap from "./src/tap";
import * as test from "./src/test";
import * as times from "./src/times";
import * as toLower from "./src/toLower";
import * as toPairs from "./src/toPairs";
import * as toPairsIn from "./src/toPairsIn";
import * as toString from "./src/toString";
import * as toUpper from "./src/toUpper";
import * as transpose from "./src/transpose";
import * as trim from "./src/trim";
import * as tryCatch from "./src/tryCatch";
import * as type from "./src/type";
import * as unapply from "./src/unapply";
import * as unary from "./src/unary";
import * as unfold from "./src/unfold";
import * as union from "./src/union";
import * as unionWith from "./src/unionWith";
import * as uniq from "./src/uniq";
import * as uniqBy from "./src/uniqBy";
import * as uniqWith from "./src/uniqWith";
import * as unless from "./src/unless";
import * as until from "./src/until";
import * as update from "./src/update";
import * as values from "./src/values";
import * as valuesIn from "./src/valuesIn";
import * as when from "./src/when";
import * as where from "./src/where";
import * as whereEq from "./src/whereEq";
import * as without from "./src/without";
import * as xprod from "./src/xprod";
import * as zip from "./src/zip";
import * as zipObj from "./src/zipObj";
import * as zipWith from "./src/zipWith";
export { __, add, addIndex, adjust, all, allPass, always, and, any, anyPass, ap, aperture, append, apply, applySpec, ascend, assoc, assocPath, binary, bind, both, call, chain, clamp, clone, comparator, complement, compose, composeK, composeP, concat, cond, construct, constructN, contains, converge, countBy, curry, curryN, dec, defaultTo, descend, difference, differenceWith, dissoc, dissocPath, divide, drop, dropLast, dropLastWhile, dropRepeats, dropRepeatsWith, dropWhile, either, empty, endsWith, eqBy, eqProps, equals, evolve, F, filter, find, findIndex, findLast, findLastIndex, flatten, flip, forEach, forEachObjIndexed, fromPairs, groupBy, groupWith, gt, gte, has, hasIn, head, identical, identity, ifElse, inc, indexBy, indexOf, init, innerJoin, insert, insertAll, intersection, intersectionWith, intersperse, into, invert, invertObj, invoker, is, isEmpty, isNil, join, juxt, keys, keysIn, last, lastIndexOf, length, lens, lensIndex, lensPath, lensProp, lift, liftN, lt, lte, map, mapAccum, mapAccumRight, mapObjIndexed, match, mathMod, max, maxBy, mean, median, memoize, memoizeWith, merge, mergeAll, mergeDeepLeft, mergeDeepRight, mergeDeepWith, mergeDeepWithKey, mergeWith, mergeWithKey, min, minBy, modulo, multiply, nAry, negate, none, not, nth, nthArg, o, objOf, of, omit, once, or, pair, partial, partialRight, partition, pathEq, pathOr, pathSatisfies, pick, pickAll, pickBy, pipe, pipeK, pipeP, pluck, prepend, product, project, prop, propEq, propIs, propOr, props, propSatisfies, range, reject, remove, repeat, replace, reverse, slice, sort, sortBy, sortWith, split, splitAt, splitEvery, splitWhen, startsWith, subtract, sum, symmetricDifference, symmetricDifferenceWith, T, tail, take, takeLast, takeLastWhile, takeWhile, tap, test, times, toLower, toPairs, toPairsIn, toString, toUpper, transpose, trim, tryCatch, type, unapply, unary, unfold, union, unionWith, uniq, uniqBy, uniqWith, unless, until, update, values, valuesIn, when, where, whereEq, without, xprod, zip, zipObj, zipWith };
