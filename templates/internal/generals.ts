import * as S from '../../src/index';

export default new S.Definition([], new S.Namespace(S.namespace)
  .append(new S.Group()
    .append(new S.Type(S.tProperty, [], 'string | number | symbol'))
    .append(new S.Type(S.tOrdered, [], 'string | number | Date')))
  .append(new S.Group()
    .append(new S.Type(S.tMorphism, ['T', 'U'], `(${S.vValue}: T) => U`))
    .append(new S.Type(S.tIndexedMorphism, ['T', 'U'], `(${S.vValue}: T, ${S.vIndex}: ${S.tIndex}, ${S.vList}: ${S.tList}<T>) => U`))
    .append(new S.Type(S.tPredicate, ['T'], `${S.tMorphism}<T, boolean>`))
    .append(new S.Type(S.tComparator, ['T'], '(a: T, b: T) => number')))
  .append(new S.Group()
    .append(new S.Type(S.tMapper, ['T', 'U'], `(${S.vMorphism}: ${S.tMorphism}<T, U>, ${S.vMappable}: ${S.tMappable}<T>) => ${S.tMappable}<U>`))
    .append(new S.Type(S.tListMapper, ['T', 'U'], `(${S.vMorphism}: ${S.tMorphism}<T, U>, ${S.vList}: ${S.tList}<T>) => U[]`))
    .append(new S.Type(S.tDictionaryMapper, ['T', 'U'], `(${S.vMorphism}: ${S.tMorphism}<T, U>, ${S.vDictionary}: ${S.tDictionary}<T>) => ${S.tDictionary}<U>`)))
  .append(new S.Group()
    .append(new S.Interface(S.tMappable, ['T'])
      .append(new S.FunctionTyping('map', ['U'], [[S.vMorphism, `${S.tMorphism}<T, U>`]], `${S.tMappable}<U>`)))
    .append(new S.Interface(S.tFilterable, ['T'])
      .append(new S.FunctionTyping('filter', [], [[S.vPreficate, `${S.tPredicate}<T>`]], `${S.tFilterable}<T>`)))
    .append(new S.Interface(S.tAppable, ['T'])
      .append(new S.FunctionTyping('ap', ['U'], [[S.vMorphism, `${S.tMorphism}<T, U>`]], `${S.tAppable}<U>`)))
    .append(new S.Interface(S.tConcatable, ['T'])
      .append(new S.FunctionTyping('concat', [], [[S.vValue, 'T']], `${S.tConcatable}<T>`)))
    .append(new S.Interface(S.tAllAble, ['T'])
      .append(new S.FunctionTyping('all', [], [[S.vPreficate, `${S.tPredicate}<T>`]], 'boolean')))
    .append(new S.Interface(S.tAnyAble, ['T'])
      .append(new S.FunctionTyping('any', [], [[S.vPreficate, `${S.tPredicate}<T>`]], 'boolean')))
    .append(new S.Interface(S.tNoneAble, ['T'])
      .append(new S.FunctionTyping('none', [], [[S.vPreficate, `${S.tPredicate}<T>`]], 'boolean'))))
  .append(new S.Group()
    .append(new S.Interface(S.tList, ['T'])
      .append(new S.PlainTyping('readonly length: number'))
      .append(new S.PlainTyping(`readonly [${S.vIndex}: ${S.tIndex}]: T`)))
    .append(new S.Interface(S.tDictionary, ['T'])
      .append(new S.PlainTyping(`[${S.vKey}: ${S.tKey}]: T`)))
    .append(new S.Interface(S.tNestedDictionary, ['T'])
      .append(new S.PlainTyping(`[${S.vKey}: ${S.tKey}]: T | ${S.tNestedDictionary}<T>`)))));
